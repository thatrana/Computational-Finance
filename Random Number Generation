#Question 1
#X_n+1 = (aX_n + b) modulo m
#in the case of LGM, m = 2^31, a= 2^16 + 3, b = 0
import numpy as np
import random
a = 7**5
m = 2**31 - 1
def generate_numbers(init_value, n):
    my_generation = [init_value]
    for i in range(1,n+1):
        my_generation.append(a*my_generation[i-1] % m)       
    return my_generation[1:]
d_1 = generate_numbers(1,10000)
#But the given range is [0,1] where as in our case, the random numbers
#generated are [0,m-1], so we have to divide with m-1 or m approximately to 
#make them random in the given range.
generate_numbers_inrange = np.multiply(d_1, 1/m)
print(generate_numbers_inrange)
mean_generated = np.mean(generate_numbers_inrange)
std_generated = np.std(generate_numbers_inrange)

#Generation of Random Numbers using python inbuilt functions
random.seed(10)
d_2 = np.random.uniform(0,1,10000)
mean_python_buitin = np.mean(d_2)
std_python_buitin = np.std(d_2)
#Comparing both the outputs but plotting histograms and checking whether they are uniformly distributed
#plot of the uniform distribution generated by the pseudo random process
import matplotlib.pyplot as plt
num_bins = 15
n, bins, patches = plt.hist(d_1,15,facecolor='blue', alpha=0.5)
plt.title('Histogram of uniform dist by LGM method')
plt.xlabel('observation bins')
plt.ylabel('no of observations')
plt.show()


#plot of the uniform distribution generated by python packages
num_bins = 15
n, bins, patches = plt.hist(d_2,15,facecolor='blue', alpha=0.5)
plt.title('Histogram of uniform dist by python in-built funct')
plt.xlabel('observation bins')
plt.ylabel('no of observations')
plt.show()
#We can observe that the method we used generated to generate' 
#the uniform distribution does the job as good as the python buit-in function'


#Question 2

#Generating random numbers using the given probabilities
p1 = 0.3
p2 = 0.35
p3 = 0.2
p4 = 0.15
def new_sequence(n):
    d = [0]*n
    for i in range(1,n):
        if generate_numbers_inrange[i] <= p1:
            d[i]  = -1
        elif generate_numbers_inrange[i]  <= p1 + p2:
            d[i]  = 0
        elif generate_numbers_inrange[i]  <= p1 + p2 + p3:
            d[i]  = 1
        else:
            d[i]  = 2
    return(d)
q_2a = new_sequence(10000)

#2b
n, bins, patches = plt.hist(q_2a,facecolor='blue', alpha=0.5)
plt.title('Histogram of uniform dist by python in-built funct')
plt.xlabel('values of x')
plt.ylabel('no of observations')
plt.show()

mean_2a = np.mean(q_2a)
std_2a = np.std(q_2a)

#3a
  
p=0.64
n=44
n_3=1000
b_p=np.zeros(n*n_3)
u_3=np.zeros(n_3)
x_3=np.zeros(n_3)
u_3=np.multiply(generate_numbers(2,44000),1/m)
for i in range(0,n*n_3):
    if u_3[i]<p:
        b_p[i]=1
    else:
        b_p[i]=0
y_3=np.zeros((n_3,n))
for i in range(0,n):
    for j in range(0,n_3):
        y_3[j,i]=b_p[j+i*n_3]
for i in range(0,n_3):
    for j in range(0,n):
        x_3[i]+=y_3[i,j]


#3b
x=0
p=[0]*1000
for i in range(1000):
    if x_3[i]>=40:
        p[i]=x_3[i]
    else:
        p[i]=0

prob = np.count_nonzero(p)/1000

#using python function
bino=np.zeros(1000)
bino=np.random.binomial(44,0.64,1000)
prob_python = np.count_nonzero(list(filter(lambda x: x>=40, bino)))/1000

plt.hist(x_3)
plt.title("Binomial Histogram")
plt.show()
     
#4a
#Exponentially distributed distribution lamba = 1.5
lamda = 1.5
y_4 = [0]*10000
for i in range(10000):
       y_4[i] = -lamda*np.log(1-generate_numbers_inrange[i])
#4b
prob_x_1 = np.size(list(filter(lambda x: x>=1, y_4)))/np.size(y_4)
prob_x_4 = np.size(list(filter(lambda x: x>=4, y_4)))/np.size(y_4)


#4c
np.mean(y_4)
np.std(y_4)
plt.hist(y_4, bins = 20)
plt.title("Exponential Ditribution")

#5a
generate_numbers(1,5000)

#5b
unif_0 = np.multiply(generate_numbers(2,5000),1/m)
unif_1 = unif_0[len(unif_0)//2:]
unif_2 = unif_0[:len(unif_0)//2]
z_1 = [0]*2500
for i in range(2500):
    z_1[i] =np.sqrt(-2*np.log(unif_1[i]))*np.cos(2*np.pi*unif_2[i])

z_2 = [0]*2500
for i in range(2500):
    z_2[i] =np.sqrt(-2*np.log(unif_1[i]))*np.sin(2*np.pi*unif_2[i])

z_5 = z_1 + z_2

plt.hist(z_5)
plt.title('Normal dist generation using Box-Muller method')

#5c
np.mean(z_5)
np.std(z_5)


#5d
unif_3 = np.multiply(generate_numbers(2,5000),1/m)
unif_4 = unif_3[:len(unif_3)//2]
unif_5 = unif_3[len(unif_3)//2:]

v_1 =[0]*2500
v_2 =[0]*2500
w = [0]*2500
X_p = np.array([1])
z_6 = []
#z_4 = [0]*2500
v_1[:] = 2*unif_4[:]-1
v_2[:] = 2*unif_5[:]-1
for i in range(2500):
    w[i] = v_1[i]**2 + v_2[i]**2
    if w[i] <= 1:
        z_3 = v_1[i]*np.sqrt(-2*np.log(w[i])/w[i])
        z_4 = v_2[i]*np.sqrt(-2*np.log(w[i])/w[i])
        X_p = np.append(X_p,z_3)
        X_p = np.append(X_p,z_4)

plt.hist(X_p)
plt.title('Normal dist generation using Polar-Marsaglia method')

np.mean(X_p)
np.std(X_p)

#5e
np.mean(z_2)
np.std(z_2)

#5f
import time
start_1 = time.time()
unif_0 = np.multiply(generate_numbers(2,5000),1/m)
unif_1 = unif_0[len(unif_0)//2:]
unif_2 = unif_0[:len(unif_0)//2]
z_1 = [0]*2500
for i in range(2500):
    z_1[i] =np.sqrt(-2*np.log(unif_1[i]))*np.cos(2*np.pi*unif_2[i])

z_2 = [0]*2500
for i in range(2500):
    z_2[i] =np.sqrt(-2*np.log(unif_1[i]))*np.sin(2*np.pi*unif_2[i])

z_5 = z_1 + z_2
end_1 = time.time()
print(end_1 - start_1) 

import time
start_2 = time.time()
unif_3 = np.multiply(generate_numbers(2,5000),1/m)
unif_4 = unif_3[:len(unif_3)//2]
unif_5 = unif_3[len(unif_3)//2:]

v_1 =[0]*2500
v_2 =[0]*2500
w = [0]*2500
X_p = np.array([1])
z_6 = []
v_1[:] = 2*unif_4[:]-1
v_2[:] = 2*unif_5[:]-1
for i in range(2500):
    w[i] = v_1[i]**2 + v_2[i]**2
    if w[i] <= 1:
        z_3 = v_1[i]*np.sqrt(-2*np.log(w[i])/w[i])
        z_4 = v_2[i]*np.sqrt(-2*np.log(w[i])/w[i])
        X_p = np.append(X_p,z_3)
        X_p = np.append(X_p,z_4)
end_2 = time.time()
print(end_2 - start_2)
#2nd method took the less ammount of time.
